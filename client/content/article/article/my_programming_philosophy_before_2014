
*这些是我2013年之前的总结，并不连贯，是从我各个笔记中找到的，暂且归整于此。它们是我当时对程序的理解，并不代表现在及其将来的思想，只是记录一下自己的思想发展历程。*

* 在写一个函数逻辑的时候，偶尔会看到某条语句在逻辑中间被调用，但其实际执行时间却在整个逻辑之后，比如一个延迟调用的语句。对于这种情况，我觉得应该将这条语句放在整个逻辑的最下面，虽然他们实际上没有区别，但对于阅读该逻辑的人员来说，放在下面就能让其非常直观的认为这条语句是最后执行的。这种将语句放在最后的做法我称之为：%red%明确引导%%:-)。
* 在阅读《祖玛》代码的时候，发现作者将路径坐标计算放在了游戏开始初始化的时候，此时计算出来的值是小数，而在用户玩游戏的时候，其计算大部分是整数计算，这的确是一种良好的做法。由此在开发的时候完全可以在“可被接受”的前提下，扩大小数到整数，从而在大部分计算中让计算机处理整数。比如“可被接受”的小数位为.001，那么我们就用1000扩大所有的这些小数，从而变成整数。
* “如果他没错，就不要动他”。这是句在计算机科学中流传的话，说这句话的人可能年代非常久远（因为这句话一开始不是给计算机说的，后来计算机科学借用），所要表达的意思也可能绝非计算机行业，但新人新译。这句话是想表达在计算机编程里面，如果程序运行OK、没有错误的情况下，即便程序的实现着实非常恶心，但开发者或者维护者尽量不要尝试去随意重构程序，不然可能出现事与愿违的结果。我将这句话联想在编程变量的初始化中。当一个变量（全局或者局部）无论它现在是什么值，只要下一步不打算用该变量，那就尽量不要去重新为其赋值，这样做是有好处的1)：
 * 既然都要初始化，那我在需要的时候初始化与最开始全部初始化在性能上没有不同，为何不把初始化的代码与其使用的代码放在一起，从而阅读清爽呢？
 * 如果你销毁了一个对象的资源数据，但他的逻辑数据（比如变量的值）还在一段时间内需要用到，此时如果你改变了里面的值，可能会产生新错误；
 * 不排除其他好处；
* 写一个设置坐标的函数，用百分数表示从左向右总长的百分之多少，如果用负百分数表示从右向左，因为这样显然更统一些；
* 之前写对象池的时候，总是习惯于在类文件中写一个静态push函数，一个get函数，还有一个数组，用户总是调用get静态方法得到一个对象，方法自然是先尝试从数组中pop出来一个对象实例，没有的话就new一个新对象返回。而当用户不用的时候我便调用push静态方法将其推进数组。还有一种方法就是维护一个free指针，它始终指向对象池中“空闲”状态的对象，池中每一个对象也维护一个指向池中另一个对象的指针，最后一个对象指向null，当free指针是null的时候，对象池就需要扩大。 Box2D扩大对象池的方法是全新创建一块2倍与之前池子大小的新池子，初始化里面全新的对象彼此之间的链条式引用，然后将之前池中对象的所有属性值拷贝过来。这样做的优点就是新的对象池中对象之间依然是一种顺序表的结构，遍历起来快，尽管插入删除慢，但是从需求来看基本不会有这样的操作。而我的方法势必打一开始就是个链表结构，适合经常需要插入、删除操作需求的应用；
* 封装一个功能可以有很多方法，比如用一个全新的数据结构去与这个功能模块交互，该模块不能与其他任何模块交互。但这也属于治标的方法，封装核心还是对外尽可能提供优质的、简明扼要的接口，从而自我封闭。
* 如果几个函数都使用同一个变量，那么我们至少有两种选择：1、将变量写成全局的形式；2、将变量作为参数传递；细细品味1、2种方法你就会发现，使用第一种确实能提高编写效率，但同样将该变量暴露给了更多的函数，倘若编写不慎可能会导致该全局变量在无意间被全新赋值；其次一个明显的问题就是我一向支持的编写方式，就是任何代码要给阅读者（包括以后阅读该代码的自己）一种尽可能简单、明确、清楚的引导（%red%明确引导%%:-)）。这种以全局变量写的方式明显没有以显示的给函数传递参数的方式更容易让读者明白“可能”会发生什么。比如int min（int，int）一看就能理解它是想返回两个参数中最小的。然而要是写成int  min()，或者int min(int)；你便会很郁闷它是试图在与谁或者哪些数字进行比较；


![laozi](/share/philosophy/laozi.jpg)
