透视除法是OpenGL中的一个固定流水线，它位于这个阶段：投影变换->裁剪->透视除法。正因为叫“透视”除法，所以它的存在离不开“透视投影”，因为在透视投影阶段四维矩阵无法对四维向量做分量乘法操作，具体来说就是我们无法让新向量的x分量等于旧向量的x与其他分量相乘的结果（其他分量同理），举个例子：

旧向量p(a,b,c,1)，新向量p'(bc,0,0,1)（新向量的x分量是旧向量yz分量之积）。现在我试图利用一个四维矩阵M左乘p向量后得到p'向量，数学证明这个无法完成。回忆一下向量p'的每个分量计算的方法吧：

\\[p'.x=M_0\times p.x+M_1\times p.y+M_2\times p.z+M_3\times p.w\\]

p'中的每个分量仅仅是p中各个分量的线性和，没有乘积形式存在。

因为四维矩阵无法完成这样的计算，但透视投影又必须要，只有增加流水线工序，叫**透视除法(perspective division)**。透视除法是说甭管你是什么投影，只要到了这个流水线阶段，OpenGL必定将每个顶点除以它的w分量，之后再抛弃w分量（一直存在，只不过不再理睬），这就表明，在OpenGL中点A(6,9,3,3)与点B(2,3,1,1)是一个点。你可能会问法线数据w分量是0，这样一来除了之后岂不是没有定义？如果你非要将法线数据当做顶点传递给顶点着色器的gl_Position的话，OpenGL可不管你传递的是什么，一概会进行透视除法，那么就会报错，所以我们一般传递的是三维的顶点，而OpenGL会自动将第四维变成1.0。

这是局部测试代码，仅仅打开双斜线注释掉的那句对渲染效果没有任何变化，而仅仅打开三斜线注释的话，你就会看到物体缩小了，因为在经过透视除法后，顶点的x,y,z值都缩小了2倍；

```cpp
attribute vec4 a_Position;
attribute vec4 a_Color;
uniform mat4 u_ViewMatrix;
uniform mat4 u_ProjMatrix;
varying vec4 v_Color;
void main() {
gl_Position = u_ProjMatrix * u_ViewMatrix * a_Position;
//gl_Position *= 2.0; //开启这行，渲染的效果不变；
///gl_Position.w *= 2.0; //开启这行，渲染对象缩小2倍；
v_Color = a_Color;
};
```

