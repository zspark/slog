
我很欣赏霍金上面的名言，一个人如果主观的自以为是起来我觉得到不太可怕，因为他有可能意识到“我是故意的”；但客观上的自以为是就可怕多了，比如“我”真心觉得就是这个样子。相比无知，自以为是应该更加可怕，因为自以为是的人会大胆的做一些可怕的事情但浑然不知。

以下是我对一些术语的口语理解：
* 平面几何投影：投影面是个平面并且投影线是直线
* 平行投影：投影线彼此平行的平面几何投影；
* 正投影：投影线与投影面垂直的平行投影；（透视投影也有正投影，更准确的应该说成是：平行正投影）
* 斜投影：投影线与投影面不垂直的平行投影；（同上）
* 透视投影：所有的透视投影图都有一个特征：投影后尺寸会缩短。
* 经典透视投影（正透视投影）：就是观察者相对于投影平面是对称的，整个自定义视椎体是个对称棱台；
* 其他透视投影：非正投影，整体而言这个自定义的棱台不是正棱台，需要在变换矩阵中加入切变矩阵，使其先转换为正棱台；

#  投影

OpenGL中的投影至少有两种，一种正交投影，一种透视投影。所谓正交投影，就是投影线彼此平行，可以分为[平行正投影](/)与[平行斜投影](/)，透视投影就是大家永生不忘的的“近大远小”的视觉投影。

<blockquote class="warn">在阅读以下内容之前，你需要明确的是：投影变换P是在几何体顶点经过了模型M、相机V矩阵变换之后才进行的。</blockquote>


##  正交投影

更多内容参见[OpenGL中的平行投影](/)

### 平行正投影

平行正投影表明不但投影线彼此要平行，还要与投影平面垂直。由于投影线彼此平行，因此不会相交，所投影的图像也不会产生“近大远小”的视觉效果，下图就是个平行正投影，远处的四边形投影到平面f上后是绿色线段n，近处的三角形投影后是蓝色的线段l（图像重叠，看的不是很清楚）。我们分析这张图可以知道物体上的顶点投影过去后，其y值不变，而x值变成了与平面f的x值相同的值。联想到三维空间，假如f是xoy平面，远处物体要平行投影，其结果应该会是物体的x，y值不变，而z值变成了0。

%mimg%Attach:image-pp-01.jpg [[<<]]平行正投影投影线示意图，不但投影线彼此要平行，还要与投影平面垂直%%

上图中的投影矩阵很简单：

\\[\begin{bmatrix} 1&0&0&0\\\0&1&0&0\\\0&0&0&0\\\0&0&0&1\\\ \end{bmatrix}\\]

<blockquote class="note">我不知道大家如何理解矩阵对顶点的变化，我说一下自己的。当一个矩阵左乘一个顶点（都是齐次的）的时候，矩阵的第一行影响变换后的新顶点的x值，第二行影响y值，第三行影响z值，第四行影响齐次坐标下的w值。拿上面矩阵来说，它的第一行只有第一个分量是1，表示最终顶点的x值只取原来顶点x值的1倍，因为其他分量是0，也影响不到。倘若第一行是2,5,0.5,2的话，表示最终顶点的x值是被变换之前的顶点的x值的2倍、y值的5倍，z值的0.5倍，还有w值的2倍所影响。再比如点一行是0,1,0,0的话，表示最终顶点的x值与原来顶点的x值没关系，其值仅仅是原来顶点的y值。（一定注意是矩阵左乘列向量）</blockquote>

从矩阵中看出变换后的点的z值不受原来点的任何分量的影响，一律是0 这也正是我们想要的结果。从数学的角度来看这样就完成了平行正投影的计算过程，但在我们的OpenGL来看，还差点火候，前辈们对投影矩阵赋予了更多任务，这个任务就是投影矩阵不但要完成数学上的投影，还要完成向CVV的投影。


我们需要先说下自定义视见体，视见体就是规定空间中什么范围内的物体最后要被呈现在显示器上，定义它的目的就是希望在该范围中的物体被成像，而不仅仅是在CVV中，这句话好像与前文有些矛盾，前文说OpenGL流水线会将视见体之外的所有顶点抛弃，这一步不是程序员能控制的了的，这里又说通过自定义视见体能扩大可是范围。这样说好像有种自定义的视见体能顶掉CVV一样。千万不要这么理解，你必须保持对CVV是裁剪的外围不变的态度。CVV裁剪既然是程序员不可控的（也许固话到了硬件上），它就一直存在。我们之所以需要再自定义个视见体，目的就是为了将我们定义的这个区域内的顶点映射到CVV空间里面（这样不是就不被裁剪了嘛），而映射这一步正就是“投影”被赋予的新任务。显然这样一来我们的工作会大大提升自由度，比如建模师可以随意建模，应用程序也可以随意指定视见体大小。将自定义视见体中的所有要显示的物体变换到CVV中，基本的思路就是：如果偏离了原点就平移回来，如果视见体比CVV大就缩小等等。比如我们自定义了一个边长为4（OpenGL中CVV边长是2），中心点在原点位置，那我们只需要将所有的顶点（是所有的）位置乘以0.5，这样一来整个世界中的几何体都缩小了8倍，那么原先在自定义视见体中的顶点不就恰好留在CVV中，而那些原先不在自定义视见体中的顶点，即便缩小了0.5倍，其新坐标也不会在被CVV包围，这就是说原先不在自定义视见体中的几何体（或者其一部分）在缩小（投影）后，会被裁减掉，这正是我们想要的，变相的扩大了CVV。


当我们将自定义视见体转换到规范视见体（CVV）的大小与位置的过程，是我们的将标架从眼空间转换到裁减空间下的过程（CVV就是在裁剪空间下），而OpenGL中的裁剪空间是左手坐标系。

> 由于屏幕坐标经常指定为左手系，因此规范化观察体也常指定为左手系统。这样就可以将观察方向的正距离解释为离屏幕（观察平面）的距离。
>
>--《计算机图形学》中文第三版 P.298 

> Because screen coordinates are often specified in a left-handed reference frame, normalized coordinates also are often specified in a left-handed system. This allows positive distances in the viewing direction to be directly interpreted as distances from the screen(the viewing plane). Thus, we can convert projection coordinates into positions within a left-handed normalized-coordinate reference frame, and these coordinate positions will then be transferred to left-handed screen coordianteds by the viewport transformation. 
>
>--《计算机图形学》英文第四版 P. 344 

可以知道这是为了以后流水线处理的方便，并没有太多需要解释的东西。这个变换是必须的，因为流水线后面阶段在判断z序的时候，是根据“z值越大越离照相机远”的逻辑来进行的，倘若不转换，成像的结果就是远处的物体在近处的前面，甚至物体本身后面也在自己的前面，what a mass！所以上面我们计算出来的矩阵M需要再右乘左右手的转换矩阵。

最终OpenGL下的平行正投影变换矩阵为：


\\[P=\begin{bmatrix}\frac {2}{R-L}&0&0&-\frac{R+L}{R-L}\\\ 0&\frac {2}{T-B}&0&-\frac {T+B}{T-B}\\\ 0&0&-\frac {2}{F-N}&-\frac{F+N}{F-N}\\\0&0&0&1\end{bmatrix}\\]

这是个基于WebGL的测试：Attach:parallel-projection-matrix.7z 

%mimg%Attach:parallel-projection-matrix.jpg 平行正投影Demo截图，框架来自**WebGL Programming Guide**中的examples


### 平行斜投影
平行斜投影就是投影线彼此平行，但投影线与投影平面不垂直的投影。下图就是一张平行斜投影的截图，从中可以简单的看出多边形ABCDE通过绿色投影线u投影到了平面f上，而我们处理它的方案是先将多边形ABCDE通过平行于f的方向错切到多边形A'B'C'D'E'的位置，然后再进行平行正投影。

%mimg%Attach:image-cg-parallel-projection.jpg =平行斜投影投影线示意图%%

所以我们将问题的核心集中在如何通过错切使ABCDE编程A'B'C'D'E'。从图4可以看出(x,z)是多边形上的任何一个点，假设为P点，它想要移动到正投影的角度，必须向x轴正方向移动\\((x_{p'}-x)\\)的距离。而这个距离正好是\\(cot\theta\\)的长度（包括符号），所以错切后的点P的位置就应该是\\((x+cot\theta * z)\\)，从图（b）中也可以看到错切后的y值应该是\\((y+cot\phi * z)\\)，这样一来，整个平行斜投影进一步变成了平行正投影，所以这个错切矩阵应该是下面这样：

\\[\begin{bmatrix} 1&0&cot\theta&0\\\ 0&1&cot\phi&0\\\ 0&0&1&0\\\ 0&0&0&1 \end{bmatrix}\\]

下面是个简单的测试程序：Attach:parallel-oblique-projection-matrix.7z

%mimg%Attach:parallel-oblique-projection-matrix.jpg 平行斜投影Demo截图，框架来自**WebGL Programming Guide**中的examples


##  透视投影
更多内容参见[OpenGL中的透视投影](/)

透视投影就是大家常见的投影后看起来很自然的有“近大远小”视觉效果的投影，远处的物体之所以投影后要变小，是因为其与COP的距离相比其它物体要远，这就给我们一个处理透视投影的思路：可以用距离来决定物体要缩放多少，这种透视被称作 **非均匀的透视缩短(nonuniform foreshortening)**

%mimg%Attach:opengl-projection-matrix-derivation/img-cg-perspective-projection.jpg 透视投影示意图，图片来自网络%%

问题的核心依然是利用一个怎样的矩阵，可以将自定义的四棱台变换到CVV下，不要忘记我们变换的重要思想：级联，所以我们完全可以这样推导：先尝试将四棱台变换成平行投影下的轴对齐立方体，然后与平行投影矩阵级联得出最终透视投影结果。

图中所示任意一点(x,y,z)，将其投影到近裁剪面后，其新坐标的y'变小了，我们通过三角函数很容易推导出来。 我们不对z值进行变化，其原因是变化了之后，所有新顶点的z值便会都成-near大小，OpenGL便不能判断出孰近孰远，也就是说丢失了原始数据，或者丢失了一个维度等等：

\\[x'=-x*near/z, y'=-y*near/z\\]

我们将视椎体内的任何一个顶点进行这样的变化后，原来顶点所构成的四棱台就会变成一个轴对齐长方体，这让我们非常开心，因为只需要如此简单的一个计算整个透视投影的数学核心逻辑就完成了。我们现在尝试将变化写成矩阵的形式：

\\[N=\begin{bmatrix} \frac{-near}{z}&0&0&0\\\0&\frac{-near}{z}&0&0\\\0&0&1&0\\\0&0&0&1 \end{bmatrix}\\]

矩阵N就数学上而言没有问题，但是该矩阵的初始化需要用到各个顶点的z值！整个逻辑是先确定顶点，然后才能通过顶点的z值确定矩阵，之后再去变化顶点。而不是流水线想要的先确定一个固定的矩阵，然后去处理一堆顶点。通过尝试我们会发现，无法确定一个“整个批次不变”的四维矩阵来完成上面的变化，但办法总比问题多，前辈们通过一个叫[透视除法](/article?n=perspective_division)的后期固定管线完成了四维矩阵无法完成的分量乘除运算。简单来说是这样的：我们在计算机图形学中使用的点与向量都是四维的，向量没有位置，w分量是0，点有位置w分量是1，w分量常规上没有其它的值，因为w在三维世界中没有意义（注意，这里的0，1应该是刻意定义的）。我们何不在透视投影中利用w分量先保存一些有用的信息，等后期再利用！尝试将上面的函数关系分成两步，第一步先乘以near，第二步除以-z。由于矩阵乘以标量是满足交换律的，所以我们在整个透视过程中暂不考虑除以-z，而是得出整个投影矩阵后再处理（当然了，除以-z是交给[透视除法](/article?n=perspective_division)的。透视投影具体推导[查看这里](xxx)，不过一定需要注意矩阵第三行(0,0,F+N,FN)的推导。

%mimg%Attach:img-cg-frustum-shrink.jpg 自定义视椎体按距离压缩，顶点所在xoy平面距离COP越远压缩的越厉害。图中A点处于近裁剪面上没有被压缩，而B点由于距离较远，其x值（从图中估计）从3个单位变成了1.2个单位。图片来自网络%%

数学上的纯透视计算其实非常简单，就是单纯的除以z值以达到距离越远越小的感觉。但OpenGL所说的透视还包括了一些额外需要处理或者考虑的信息：

* 裁剪空间z轴与眼空间方向相反；
* 裁剪模块只接受满足\\(w>=x,y,z>=-w(w>0)\\)的顶点，故此如果你计算出的w是负数，那么顶点就会被抛弃，因为负数是永远小于其相反数的，这也正是为什么near far需要用到正数，显然负数更直观些（用负数推导的话会导致w为负数，查看[why-near-far-plane-are-positive-values](/)的推导与实验结果）；
* 透视除法后要保证在自定义视见体内的顶点能落在CVV所在的NDC空间；

最终的透视投影矩阵：

\\[P=\begin{bmatrix} \frac{-2near}{R-L}&0&\frac{R+L}{R-L}&0\\\0&\frac{-2near}{T-B}&\frac {T+B}{T-B}&0\\\0&0&-\frac {far+near}{far-near}&-\frac{2far*near}{far-near}\\\0&0&-1&0 \end{bmatrix}\\]

\\[R=tan(FOVH*.5)near,L=-R\\]

\\[T=tan(FOVV*.5)near,B=-T\\]

# 观察API
观察API就是用简单的方式指定照相机或者眼睛的位置与方位的函数，理论上只要能实现具体指定眼标架即可，这部分内容有些老旧。书中特意说到了两个常用API：

* VRP、VPN、VUP：
 * VRP（view-referecne point）：观察参考点，就是指定眼标架在位置；
 * VPN（view-plane normal）：观察平面法向量，指定眼标架的z轴；
 * VUP（view-up vector）：观察正向向量，就是照相机打算观察的区域正向；
* LookAt();

# 剔除、多边形偏移、阴影
%rimg%Attach:z-fighting.jpg  Z冲突可能出现的效果 图片来自[[http://www.zeuscmd.com/tutorials/opengl/15-PolygonOffset.php|zeuscmd]]%%

三角形都有2个面，这就需要指定哪个是正面，哪个是反面，OpenGL默认使用逆时针方向为正：右手四指沿着给出三角形三个顶点的顺序握住，拇指向上所指便是正向。我们可以利用[[glFrontFace]]函数来指定想要的顺序。OpenGL这么做的原因在于想给应用更多的灵活性。指定了三角面正向后，需要启用剔除功能glEnable(GL_CULL_FACE)，再使用[[glCullFace]]，参数为GL_FRONT、GL_BACK、GL_FRONT_AND_BACK，具体指定要剔除的方向。

如果你既想给三角形涂纯色，又想给它描边（纯色与描边色不同），这就需要用到多边形偏移，否则会出现z冲突效果。使用的话依然需要先开启多边形偏移：glEnable(GL_POLYGON_OFFSET_X)，然后使用glPolygonOffset函数指定必要的参数；关于阴影，可查阅[shadow map](https://en.wikipedia.org/wiki/Shadow_mapping)[shadow volume](https://en.wikipedia.org/wiki/Shadow_volume)等相关技术。

> 一些图形系统利用在定义多边形时指定的前三个顶点自动计算出法向量。OpenGL没有这样做，把计算法向量的任务留给应用程序可以为应用光照模型提供更多的灵活性。 
>
>-- 《计算机图形学》中文第三版。

# 总结
我读这一章总觉得应该抓住第三章的关键词“空间变换”去帮助理解。初学者可能很容易想到空间变换是诸如平移、缩放等等的变换，的确但同时比较狭隘。第四章的各种投影无非就是空间之间的变换，比如平行投影与透视投影都是将用户给定的视椎体变换到一个被称作`规范视椎体（CVV，canonical view volume）`的空间里面，目的就是为了在后期好进行裁剪、设备坐标系好映射。我读第四章始终觉得Edward没有强调这个概念，以至于读者难以从第三章平滑过渡到第四章。还有一点我觉得不太好的地方在于Edward在讲解透视规范化矩阵的时候，有点先结果后原因的意思，这也不利于读者对其进行最初的认知。如果能从那些图形学前辈如何慢慢形成现在的图形学科学的角度去讲，肯定是最好，因为这肯定符合认知过程。

整个交计图的第四章利用第三章的空间变化为基础，逐步说明了如何将空间中指定大小、方向的立方体、平截椎体变换到指定的CVV下的计算过程。CVV是整个绘制流水线中连接顶点处理与光栅化、片元处理的中间节点，是对顶点位置的归一化呈现，便于后期处理，普通应用没有更多的用处，也没有什么好纠结为什么要转换到CVV下。章节中还介绍了几个观察API，书中安排的较前边一些，我第一次读感觉很糊涂，不能明确联系它与后面推导的关系，如果有前辈指导自然方便很多。后边还介绍了剔除面、多边形偏移与阴影，这些都对计图理论形成没有多少帮助，但在实际使用中非常必要。





