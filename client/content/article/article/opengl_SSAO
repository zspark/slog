*all code from learn OpenGL : copied from : https://learnopengl.com/code_viewer.php?code=advanced-lighting/ssao&type=fragment*

我从下面3个点进行说明：
# 一 原理
## 离屏framebuffer（ COffscreenRenderTarget_SSAO ）
我们需要2个framebuffer
### 计算遮蔽系数
输入：
* texture : position in eye space; (the output of regular program)
* texture : normal in eye space; (the output of regular program)
* texture : noise; (procedure texture)
* texture : sample kernel; (procedure texture)
输出：
* texture : occlusion texture; (GL_RGBA or other supported internal format, temporary texture)

### 模糊+调制图像
输入：
* texture : occlusion texture; ( the output texture of the above )
* texture : image rendered by regular shader; ( the out of regular program)
输出：
* texture : the final texture;

## 采样内核
采样内核是运行在GPU上的一段对于SSAO来说非常重要的核心逻辑，每个像素都要经过该内核逻辑。采样内核的采样数量越大，理论上SSAO效果越好，同样也越耗时。

## 噪声纹理
噪声纹理在现代渲染中扮演着越来越重要的角色，前一段时间听说希望能通过硬件实现。

与其他使用噪声纹理作为随机数生成器的目的一致，SSAO中使用其为每一个像素提供尽可能不同的方向，从而计算出不同的TBN空间，这个过程称为“旋转内核”（动词，非term）

下面代码是fragment shader中将采样到的数据计算为tangent法线的方法
```cpp
vec3 tangent = normalize(randomVec - normal * dot(randomVec, normal));
```


噪声纹理运行时生产，也可以是图像提供。

# 二 实现
## 采样内核
```cpp
// ----------------------
// generate sample kernel
std::uniform_real_distribution<GLfloat> randomFloats(0.0, 1.0); 
std::default_random_engine generator;
std::vector<glm::vec3> ssaoKernel;
for (unsigned int i = 0; i < 64; ++i) {
  glm::vec3 sample(
    randomFloats(generator) * 2.0 - 1.0, 
    randomFloats(generator) * 2.0 - 1.0,
    randomFloats(generator));

  sample = glm::normalize(sample);
  sample *= randomFloats(generator);
  float scale = float(i) / 64.0;

  // scale samples s.t. they're more aligned to center of kernel
  scale = lerp(0.1f, 1.0f, scale * scale);
  sample *= scale;
  ssaoKernel.push_back(sample);
}
```

```cpp
for(int i = 0; i < kernelSize; ++i) {
  // get sample position
  vec3 sample = TBN * samples[i]; // From tangent to view-space
  sample = fragPos + sample * radius; 

  // project sample position (to sample texture) (to get position on screen/texture)
  vec4 offset = vec4(sample, 1.0);
  offset = projection * offset; // from view to clip-space
  offset.xyz /= offset.w; // perspective divide
  offset.xyz = offset.xyz * 0.5 + 0.5; // transform to range 0.0 - 1.0

  // get sample depth
  float sampleDepth = -texture(gPositionDepth, offset.xy).w; // Get depth value of kernel sample

  // range check & accumulate
  float rangeCheck = smoothstep(0.0, 1.0, radius / abs(fragPos.z - sampleDepth ));
  occlusion += (sampleDepth >= sample.z ? 1.0 : 0.0) * rangeCheck;           
}
occlusion = 1.0 - (occlusion / kernelSize);
```

## 模糊
```cpp
#version 330 core
out float FragColor;
in vec2 TexCoords;
uniform sampler2D ssaoInput;

void main(){
    vec2 texelSize = 1.0 / vec2(textureSize(ssaoInput, 0));
    float result = 0.0;
    for (int x = -2; x < 2; ++x){
        for (int y = -2; y < 2; ++y){
            vec2 offset = vec2(float(x), float(y)) * texelSize;
            result += texture(ssaoInput, TexCoords + offset).r;
        }
    }
    FragColor = result / (4.0 * 4.0);
}
```
我截断了原有拷贝离屏FBO的输出，转而将其输入到一个全新的SSAO离屏渲染器，作为输入，最后将该SSAO的结果拷贝给我原来想要的数据结构里面。

# 三 注意点

* 注意使用glDrawBuffers开启MRT的输出;
* shader与移动端兼容;
* MRT输出;
* 采样内核集中;
* 偏移;
* 应该是z值的深度比较，我们却是y，注意;
* float纹理的使用；
