### 1. 基本思想
用水平线从上到下(或从下到上)扫描由多条首位相连的线段构成的多边形，每根扫描线与多边形的某些边产生一系列的交点。将这些交点按x坐标排序，将排序后的点两两成对，作为线段的端点，以所填的颜色画水平的直线。多边形被扫描完毕后，颜色填充也就完成了。此算法可归纳为以下四个步骤：
1. 求交，计算扫描线与多边形的交点；
2. 交点排序，对第1步得到的交点按照x值从小到大进行排序；
3. 颜色填充，对排序后的交点两两组成一个水平线段，以画线段的方式进行颜色填充；
4. 是否完成多边形扫描？是就结束算法，不是就改变扫描线，然后转第一步继续处理；

整个算法的关键是第1步，需要用尽量少的计算量求出交点，还要考虑交点是线段端点的特殊情况，最后，交点的步进计算最好是整数，便于光栅设备输出显示。   
观察多边形与扫描线的交点情况(图略，后补)，可以得到以下两个特点：
* 每次只有相关的几条边可能与扫描线有交点，不必对所有的边进行求交计算；
* 相邻的扫描线与同一直线段的交点存在步进关系，这个关系与直线段所在直线的斜率有关；

第一个特点是显而易见的，为了减少计算量，扫描线算法需要维护一张由“活动边”组成的表，称为“活动边表（AET）”。   
第二个特点可以进一步证明，假设当前扫描线与多边形的某一条边的交点已经通过直线段求交算法计算出来，得到交点坐标为(x,y)，则下一条扫描线与这条边的交点不需要再求交计算，通过步进关系可以得到新交点坐标为(x+△x,y+1)。步进关系△x是个常量，与直线的斜率有关。
### 2. 交点推导 
假设多边形某条便所在的直线方程是：ax + by + c = 0   
扫描线yi和下一条扫描线yi+1与该边的两个交点分别是(xi,yi)和(xi+1,yi+1)   
则可以得到以下两个等式(以下的i 与 i+1为下标)：   
axi + byi + c = 0      (1)   
axi+1 + byi+1 + c = 0  (2)   
联立两个等式可得：   
xi+1 - xi = -b(yi+1-yi)/a   （3）   
由于扫描线 Y(i+1) = Y(i) + 1   
可得： X(i+1) - Xi = -b / a （常量，直线斜率的倒数） 
即： **△x = -b / a;**

### 3. 活动边表
“活动边表”是扫描线填充算法的核心，整个算法都是围绕者这张表进行处理的。要完整的定义“活动边表”，需要先定义边的数据结构。每条边都和扫描线有个交点，**扫描线填充算法只关注交点的x坐标。每当处理下一条扫描线时，根据△x直接计算出新扫描线与边的交点x坐标，可以避免复杂的计算。** 一条边不会一直待在“活动边表”中，当扫描线与之没有交点时，要将其从“活动边表”中移除，判断是否有交点的依据就是看**扫描线y是否大于这条边的两个端点的y坐标值，为此要记录边的y坐标的最大值。**   

为了避免维护多张表，不独立构造“活动边表”，而是直接在“边表”中划定一部分区间作为“活动边区间”，即把多边形的边分成两个子集，一个是与扫描线有交点的边的集合，另一个是与扫描线没有交点的边的集合。要达到这个目的，只需要对“活动边表”按照每条边的顶点ymax坐标排序即可。因为**只有边的ymax坐标区间内与扫描线有交点的边才可能是“活动边”。** 为了避免重复扫描整个“活动边表”，**需要用一个first指针和一个last指针用于标识“活动边区间”。first指针之前的边都是已经处理过的边，last指针之后的边都是还没处理的边。** 每处理完一条扫描线，都要跟新first和last指针的位置，**调整last指针的位置将yamx大于当前扫描线的边纳入到“活动边区间”，同时调整first指针将处理完成的边排除在“活动边区间”之外。**    

调整last指针的一句是边的ymax是否大于当前扫描线。那么调整first指针的依据是什么？如何判断一条边已经处理完了？方法是在边定义中增加一个dy(Δy)属性，这个属性是被初始化成这条边在y方向上的长度。

“边”的结构定义如下：
```cpp
typedef struct _Edge  // 边表结构
{
    double xi;   // 扫描线与多边形交点的x坐标
    double dx;   // dx = - b/a 直线斜率的倒数
    int ymax;    // 这条边上端点的y坐标
    int dy;      // 初始化为这条边在y方向上的长度，
                 // 每处理完一条扫描线，--dy,当0==dy时，这条边已经不与扫描线相交
}Edge;
```
每当处理一条扫描线时，除了“活动边区间”的first和last需要调整之外，还要将first和last之间的“活动边”按照xi从小到大的顺序排序，以保证填充算法能够正确的交点线段序列画线填充。因此，每次调整“活动边区间”的first指针和last指针之后，都要对“活动边区间”重新排序，也就是说“活动边区间”内的各边位置并不固定，会随着扫描线的变化而相应的变化。

### 4. 一些细节
#### （1）多边形顶点处理
在对多边形的边进行求交的过程中，在两条边相连的顶点处会出现一些特殊情况。因为此时两条边会和扫描线各求一个交点，也就是说，在顶点位置会出现两个交点。当出现这种情况的时候，会对填充产生影响，因为填充的过程时成对选择交点的过程，错误的计算交点个数，会造成填充异常。   
假设多边形按照顶点P1、P2和P3的顺序产生两条相邻的边，P2就是所说的顶点。多边形的顶点一般有四种情况，图略 后补：   
**注意：这里的坐标是左下角为原点(0，0) 即y↑→x ；若左上为原点则相反。**
* 左顶点――P1、P2和P3的y坐标满足条件 ：y1 < y2 < y3；   
* 右顶点――P1、P2和P3的y坐标满足条件 ：y1 > y2 > y3；   
* 上顶点――P1、P2和P3的y坐标满足条件 ：y2 > y1 && y2 > y3；   
* 下顶点――P1、P2和P3的y坐标满足条件 ：y2 < y1 && y2 < y3   

对于左顶点和右顶点的情况，如果不做特殊处理会导致奇偶奇数错误，常采用的修正方法是修改以顶点为终点的那条边的区间，将顶点排除在区间之外，也就是删除这条边的终点，这样在计算交点时，就可以少计算一个交点，平衡和交点奇偶个数。结合前文定义的“边”数据结构：EDGE，只要将该边的ymax修改为ymax – 1就可以了。   
对于上顶点和下顶点，一种处理方法是将交点计算做0个，也就是修正两条边的区间，将交点从两条边中排除；另一种处理方法是不做特殊处理，就计算2个交点，这样也能保证交点奇偶个数平衡。

#### （2）水平边的处理
水平边与扫描线重合，会产生很多交点，通常的做法是将水平边直接画出（填充），然后在后面的处理中就忽略水平边，不对其进行求交计算。

#### （3）如何避免填充越过边界线
边界像素的取舍问题也需要特别注意。多边形的边界与扫描线会产生两个交点，填充时如果对两个交点以及之间的区域都填充，容易造成填充范围扩大，影响最终光栅图形化显示的填充效果。为此，人们提出了“左闭右开”的原则，简单解释就是，如果扫描线交点是1和9，则实际填充的区间是\[1,9),即不包括x坐标是9的那个点。

### 5. 算法实现
另起一篇。点击： 
[C++实现多边形扫描线填充算法](/view?n=cpp_polygon_scan_line)

参考：   
https://blog.csdn.net/orbit/article/details/7368996   
https://blog.csdn.net/orbit/article/details/7393022   
http://www.twinklingstar.cn/2013/325/region-polygon-fill-scan-line/
