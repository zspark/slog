

# 数据结构复习——查找算法之静态查找

对查找表经常进行的操作有：

* 查询某个“特定的”数据元素是否在查找表中；
* 检索某个“特定的”数据元素的各种属性；
* 在查找表中插入一个数据元素；
* 从查找表中删去某个特定元素；

只做前两种操作的查找表为**静态查找表**；查找过程中要做插入和删除操作的查找表为**动态查找表**

查找算法性能分析：时间复杂度、空间复杂度、平均查找长度对于含有n个记录的表，查找成功时的**平均查找长度**为：

>
>ASL =  \\( \sum\\)P,,i,,C,,i,, ,i=1,2,...n
>
>其中：
>
>P,,i,,为查找表中第i个记录的概率，且\\( \sum\\)P,,i,, = 1 ,i=1,2,...n
>
>C,,i,,为找到目标关键字时，和给定值已经比较过的关键字个数。
>

## 一、静态查找

* 顺序查找  时间复杂度为O(n) 
```cpp
//a为待查找数组，n为查找数组的长度，key为查找的关键字
int sqSearch(int *a, int n, int key)
{
    int i = n;
    a[0] = key;
    while(a[i]!=key)
    {
        i--;
    }
    return i;
}
```

* 折半查找 时间复杂度为O( log,,2,,n )

>先确定待查记录所在范围，再逐步缩小范围直到找到或找不到该记录为止。

```cpp
#include<iostream>
using namespace std;
//迭代
int binSearch(int str[], int n, int key)
{
	int low,high,mid;
	low = 0;
	high = n-1;
	while( low <= high )
	{
		mid = (low + high)/2;
		if(str[mid] == key)
		{
			return mid;     //查找成功
		}
		if(str[mid] < key)
		{
			low = mid +1;   //在后半序列中查找
		}
		if(str[mid] > key)
		{
			high = mid -1;  //在前半序列查找
		}
	}
	return -1;              //查找失败
}

//递归
int refind(int *data,int begin,int end,int num)
{
	if(begin > end)
	{
		//cout<<"没找到"<<endl;
		return -1;
	}

	int mid = (begin+end)/2;

	if(data[mid] == num)
	{
		return mid;
	}
	else if(data[mid] <= num)
		return refind(data,mid+1,end,num);
	else
		return refind(data,begin,mid-1,num);
}

int main()
{
	int str[11] = {1,1,2,3,5,7,9,11,23,32,33};
	int n, addr;

	cout<<"请输入待查找关键字： ";
	cin>>n;

	//addr = binSearch(str,11,n);
	addr = refind(str,0,10,n);
	if(-1 != addr)
	{
		cout<<"查找成功，关键字 "<<n<<" 所在的位置是："<<addr<<endl;
	}
	else
	{
		cout<<"查找失败"<<endl;
	}
	return 0;
}

```
* 插值查找  时间复杂度为O( log,,2,,n )


>插值查找只适合关键字均匀分布的表


```cpp
int binSearch(int str[], int n, int key)
{
	int low,high,mid;
	low = 0;
	high = n-1;
	while( low <= high )
	{
		//mid = (low + high)/2;  //折半查找
		mid = low+float(1.0*(key-str[low])/(str[high]-str[low]))*(high-low);  //插值查找
		if(str[mid] == key)
		{
			return mid;     //查找成功
		}
		if(str[mid] < key)
		{
			low = mid +1;   //在后半序列中查找
		}
		if(str[mid] > key)
		{
			high = mid -1;  //在前半序列查找
		}
	}
	return -1;              //查找失败
}
```

* 斐波那契查找 时间复杂度为O( log,,2,,n )

```cpp
// 斐波那契查找.cpp 

#include <memory>
#include  <iostream>
using namespace std;

const int max_size=20;//斐波那契数组的长度

/*构造一个斐波那契数组*/ 
void Fibonacci(int * F)
{
    F[0]=0;
    F[1]=1;
    for(int i=2;i<max_size;++i)
        F[i]=F[i-1]+F[i-2];
}

/*定义斐波那契查找法*/  
int FibonacciSearch(int *a, int n, int key)  //a为要查找的数组,n为要查找的数组长度,key为要查找的关键字
{
  int low=0;
  int high=n-1;
  
  int F[max_size];
  Fibonacci(F);//构造一个斐波那契数组F 

  int k=0;
  while(n>F[k]-1)//计算n位于斐波那契数列的位置
      ++k;

  int  * temp;//将数组a扩展到F[k]-1的长度
  temp=new int [F[k]-1];
  memcpy(temp,a,n*sizeof(int));

  for(int i=n;i<F[k]-1;++i)
     temp[i]=a[n-1];
  
  while(low<=high)
  {
    int mid=low+F[k-1]-1;
    if(key<temp[mid])
    {
      high=mid-1;
      k-=1;
    }
    else if(key>temp[mid])
    {
     low=mid+1;
     k-=2;
    }
    else
    {
       if(mid<n)
           return mid; //若相等则说明mid即为查找到的位置
       else
           return n-1; //若mid>=n则说明是扩展的数值,返回n-1
    }
  }  
  delete [] temp;
  return -1;
}

int main()
{
    int a[] = {0,16,24,35,47,59,62,73,88,99};
    int key=16;
    int index=FibonacciSearch(a,sizeof(a)/sizeof(int),key);
    cout<<key<<" is located at:"<<index;
    return 0;
}
```

* 分块查找

>又称索引顺序查找，是顺序查找的一种改进方法，尚需建立一个“索引表”。
>
>每个索引项包括两个内容：1关键字项（其值为孩子表内的做大关键字），2指针项（指示该子表的第一个记录在表中的位置）。
>
>索引表按关键字有序，则 表 有序或分块有序。
>
>分块查找过程分两步：
>
>确定要查找的关键字可能存在的具体块（子表）；
>
>在具体的块中进行顺序查找。
>


# 数据结构复习——查找算法之动态查找



## 二、动态查找
* 二叉排序树

```cpp
#include <iostream>
using namespace std;

//二叉树的二叉链表结点结构定义
typedef struct BiTNode
{
	int data;
	struct BiTNode *lchild, *rchild;
}BiTNode,*BiTree;


//递归查找二叉排序树 T 中是否存在key
//指针 f 指向 T 的双亲，其初始值调用值为NULL
//若茶中成功，则指针 p 指向该数据元素结点，并返回TRUE
//否则指针 p 指向查找路径上访问的最后一个结点，并返回FALSE
bool SearchBST(BiTree T, int key, BiTree f, BiTree *p)
{
	if(!T) //查找不成功
	{
		*p = f;
		return FALSE;
	}
	else if( key == T->data )  //查找成功
	{
		*p = T;
		return TRUE;
	}
	else if( key < T->data )
	{
		return SearchBST( T->lchild, key, T, p);  //在左子树查找
	}
	else
	{
		return SearchBST( T->lchild, key, T, p);  //在右子树继续查找
	}
}

//当二叉排序树 T 中不存在关键字等于 key 的数据元素时，
//插入 key 并返回TRUE，否则返回 FALSE
bool InsertBST(BiTree *T, int key)
{
	BiTree p, s;
	if( !SearchBST(*T, key, NULL, &p))
	{
		s = (BiTree)malloc(sizeof(BiTNode));
		s->data = key;
		s->lchild = s->rchild = NULL;

		if( !p ) //查不到 key
		{
			*T = s;   //插入s为新的根节点
		}
		else if( key < p->data )
		{
			p->lchild = s;  // 插入 s 为左孩子
		}
		else
		{
			p->rchild = s;  // 插入 s 为右孩子
		}
	}
	else
	{
		return FALSE;   // 树中已有关键字相同的结点，不再插入
	}
}

void InOrder(BiTree T)    //先序遍历
{
  if(T != NULL)
  {
    InOrder(T->lchild);
    cout<<" "<<T->data<<" ";
    InOrder(T->rchild);
  }
}

int main()
{
  BiTree T = new BiTNode();
  T->data = 3;
  T->lchild = T->rchild = NULL;

  for(int i = 0; i < 5; i++)
  {
    insertBST(&T,i);
  }
  cout<<T->data<<endl;
  InOrder(T);
  cout<<endl;
  return 0;
}

```

以上方法用到二级指针，比较复杂，jerry老师帮我简化了下

```cpp
#include <iostream>
using namespace std;

struct BiTree
{
    int data{-1};
    BiTree* lchild{nullptr};
    BiTree* rchild{nullptr};
};

BiTree* SearchAndInsert(BiTree* t, int data)
{
    if(t == nullptr)
    {
        BiTree* _t = new BiTree();
        _t->data = data;
        return _t;
    }
    if(t->data > data)
    {
        Bitree* tmp = SearchAndInsert(t->lchild,data);
        if(tmp) t->lchild = tmp;
    }
    else if(t->data < data)
    {
        BiTree* tmp = SearchAndInsert(t->rchild,data);
        if(tmp) t->rchild = tmp;
    }
    return nullptr;
}

void Print(BiTree* t){
	if(t==nullptr)return;
	Print(t->lChild);
	cout<<t->data<<",";
	Print(t->rChild);
};

int main(int argc, char** argv){

	BiTree* tree=new BiTree();
	tree->data=50;

	for(int i=0;i<100;++i){
		SearchAndInsert(tree,i);
	}

	Print(tree);

	return 0;
}
```