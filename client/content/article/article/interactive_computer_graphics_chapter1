*这是我复习Edward Angel与Dave Shreiner的合著《交互式计算机图形学 基于OpenGL着色器的自顶向下方法（第六版）》的笔记。经典教材需要经常阅读，加深记忆，修正理解，获取新知。*

#  图形系统和模型
> 计算机图形学考虑的是用计算机生成图片或者图像的方方面面，包括但不限于图形图像的生成、处理、显示。主要活跃的有至少两个分支：a.图形人机接口；b.可视化技术。1995年第一款3dfx Voodoo图形加速卡首次发布，GPU的绘制结构发生了明显变化，经历了从有限的固化算法（Fixed-Function GPU）到统一渲染架构下的完全可编程GPU（Programmable GPU），其后再经过OpenGL ES和WebGL扩展到移动互联网领域。 
>
>  -- 《交互式计算机图形学》

##  图形系统主要包括7个主要的物理部件：
*   输入设备
*   输出设备
*   CPU
*   GPU
*   存储器
*   帧缓存 

##  呈像模型
*   虚拟照相机模型：从小孔成像说起；
*   笔试绘图仪模型：其方法类似于，moveto，lineto 

如果设计的图像系统是基于虚拟照相机模型的话，其在API的设计上需要有相应的函数来确定以下四中对象：
*   对象
*   观察者
*   光源
*   材质属性 

#  图形绘制流水线
图元的类型与顶点集定义了场景的几何数据。 一个普通场景可能需要几千甚至几万个顶点，复杂场景就更多了。如此多的数据就需要流水线的方式去处理这些数据，各个模块只负责处理好自己的任务。图形绘制流水线主要由两部分组成：

*   流水线前端处理
*   流水线后端处理 

##  流水线前端处理
这个阶段的流水线主要针对顶点与图元在几何定义阶段的计算与处理，包括顶点处理与片元裁剪重组两个模块。

###  1）顶点处理
顶点处理模块的功能是批量的对所有顶点进行矩阵变化与颜色计算，矩阵变换是指将模型在制作阶段的物体坐标系变换到3D场景的世界坐标系下，然后继续变换到观察者（照相机）坐标系下。这个过程至少需要2次矩阵乘法，我们可以先将模型变化矩阵与视角变化矩阵相乘，从而得到被称作模视矩阵(mv)的新矩阵，然后再与各个顶点相乘。

这个模块还可以进行顶点颜色的计算，可以使用常见的光照模型，比如[Phong](/view?n=light_model_phong)模型；亦可使用立即数直接指定统一的顶点颜色。此前我有疑问为什么要这么早计算顶点的颜色或者计算的意义在哪里。首先顶点的光照计算肯定要放在绘制流水线的前端处理，因为无论什么场景在一帧中的显示画面是一定的，比如对象/光源位置、光源强度、观察角度等，而需要计算的是一大批符合物理光照规律的顶点，用流水线肯定没错。而计算的意义在于为后端光栅化处理向帧缓存写入片元颜色奠定的数据基础，不然一个线段只定义两个顶点，要绘制在显示器上，倘若没有顶点处理阶段时对颜色的计算处理，线段中间的顶点选什么颜色？倘若端点颜色全部是黑色，中间顶点是黑色无可厚非；一个端点白色，一个黑色，中间顶点就需要插值计算，显示结果便是个渐变线段；指定固定颜色就更好说了，经常在Demo中看到的屏幕上一个纯色三角形，那就是指定了三个顶点全是红色的绘制结果，也可以通过flat插值方式，让整个三角面使用最后一个顶点的颜色，这样渲染下来也是纯色。

###  2）图元的裁剪与重组
注意这里词汇的变化，将顶点改成了图元。这就意味着这个模块处理的最小单元是由顶点构成的图元，所谓图元就是具体的图形图像系统指定的最基本的图形，比如三角形、线段、圆等。图元的裁剪与重组是将视角（摄像机、观察者的眼睛）不可见的物体部分彻底剔除，流水线会将几何体不可见的部分按照一定的裁剪算法进行处理，然后将可见部分重组成一个或多个新的图元。至于摄像机后边的独立几何体我们是全部看不见的，也就没有必要让它的数据完整的走过流水线，这个过滤过程一般是在引擎的BSP阶段直接排除，而不是让流水线来处理。裁剪掉的不作处理，处理了也没有意义。但能看见的图元尚需要进行投影变换，其目的是将这些图元映射到投影平面上，从而防止光栅化后进行更多投影的矩阵计算。此期间会涉及到四维矩阵，其中第四维度一般会用来存储原始图元深度，从而在更后期的片元处理阶段比较大小决定谁应该压着谁。

##  流水线后端处理
这个阶段更多的操作是位级别的操作，比如对像素颜色的填充和对片元颜色的混合。
> 所有现代图形系统都是基于光栅的。 
> 
> --《计算机图形学》第三版

###  1）光栅化
光栅化就是将几何图元像素化。我们在给图元定义的时候，一个线段就是两个顶点，4个浮点数，一个三角形就是三个顶点。拿三个不共线的顶点来说吧，这么简单的数据想要在显示器上绘制出来一个完整的面，请问其他数据从何而来？比如三角形中间某一个像素颜色从何而来？位置从何而来？这就是光栅化模块要做的事情，它是利用高效的光栅化算法比如Bresenham（布兰森汉姆）算法、DDA（数字微分分析器）算法等，计算像素位置与差值计算颜色。每一个在视锥体（frustum）内的图元都要进行光栅化，其结果是将图元细分为片元((片元可以认为是像素的一个超集，它所承载的数据不仅仅是像素的颜色，还有深度信息等等。))（fragment），输出会直接进入帧缓存中。在整个过程中，不可避免的会将在视椎体内但被更靠前的物体遮挡的图元也进行光栅化后将片元尝试载入帧缓存，此时会判断片元深度，从而丢掉被压着的片元。

###  2）片元处理
片元处理是绘制流水线的最后一道工序，这个阶段才是我们经常说的纹理映射阶段。我们可以采用传统的纹理映射，也可以使用凹凸映射这种比较新的技术。映射结束后颜色缓存中的每个像素的颜色就是纹理必要位置的颜色，再与此前顶点处理阶段对顶点早期指定（或计算）的颜色进行某种混合，就成为最终屏幕像素的颜色了。此处‘某种混合’就OpenGL来说一共有16中，基本上概全了对颜色中任何一位的与或非异或等操作。

#  性能特征
《交互式计算机图形学》第一章还说到了性能特征，就是业界对于一款图像显示卡的判断，主要有两条：

* 能以多块的速度处理几何实体；
* 每秒能修改多少个帧缓存中像素的颜色； 

#  总结
交计图中第一章重点我觉得就这些东西，它是一个总述的章节，希望能从全盘先给读者一个轮廓，然后带着问题、好奇与目前的初步理解从第二章开始按照上面的顺序往下走，这也是交计图这本书作者Edward Angel多年教学颇为成功的方式。






