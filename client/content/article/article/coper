
这是我在上一家公司用C++写的一个文件拷贝工具，正所谓“懒人创造了世界”，就是因为当初在做项目的时候需要时不时的出软件新版本供QA部门使用，而运行需要的二进制文件、资源分布在好多零碎的目录下，长久下来，大家都懂这是件痛苦的过程。coper最老的版本是用AS脚本语言写的，就因为AS更加高层，能快速的完成基本的功能。后来程序功能见多，代码也在得空重构的更加合理，慢慢就觉得这功能日后肯定是个钢需，于是就找时间移植到了C++版本，由于最初的移植目的仅仅是能跑起来，没有考虑其它方面，所以在移植结束后，整个C++项目散发着浓郁的脚本感，每每回顾令人心生不快，这才有了近期的再次重构，更具体的说应该是重写了一个全新的coper。coper简单的理解就是copy的工具，现在在我重新的设计下有了删除，裁剪，正则匹配等功能，但名字依然用coper，无它，仅仅是种情怀。

<blockquote class="note">
coper源码目前在github可供下载：https://github.com/zspark/coperC

但其中需要我的另一个通用库项目cllib.lib及其头文件，暂不提供。不过coper源码已经能明确的说明它的结构与解析细节了。
</blockquote>

## coper的整个运行过程如下：

* 配置文件处理
 * 加载配置文件，解析parameter条目
 * 词法语法验证待解析条目，装载可用条目
* 文件存在性验证
* 文件操作：删除、复制、裁剪

## coper目前的设计有3种匹配方案

* 完成目录、文件名匹配；
* 通用扩展名匹配；
* 正则表达式匹配；

有3种针对目录与文件的操作：

* 删除；
* 裁剪；
* 复制；

# 名词约定 

* 条目：配置文件中正常的一行语句，包括注释语句，空行；
* 全文件名：指完整的文件名，包括扩展名；
* 文件名：指没有扩展名的全文件名；
* 扩展名：指没有文件名的全文件名，必须要有前导小数点，不然coper会判断是个文件名；
* 通用扩展名：指组中所有文件的缺省扩展名，组中文件如果没有明确扩展名的话一律使用通用扩展名；

# 关键字符、词 

|  关键字、词      |  说明                   |
| :--: | :--: |
|  parameter  | 命令参数                  |
|  <          | 组（group）开始关键字         |
|  >          | 组结束关键字                |
|  (管道符)         | 组内部子项                 |
|  /          | 目录                    |
|  >>     | 正则表达式开始，目前只能匹配目录中的文件  |

# Coper词法 

* 只要是window系统规定的合法字符 `不包括 / \ : * ? " < > |`组成的目录、文件名，都是可以通过词法检测；
* 如果使用通配符*，那么要有一定的词法结构见下面通配符的使用;
* 通用扩展名前面如果没有小数点，词法分析器会自动加上；
* 目录，全文件名两端如果存在空格等空字符，词法分析器会自动删除；
* -r -t 命令的参数为一个目录，如果没有以'/'结尾，词法分析器会自动添加；
* 词法分析器不对正则表达式做检测；

# Coper语法 

* 条目开头如果是`#`说明是一条注释语句，coper不做分析；
* 关键字`parameter`可以出现在配置文件的任何地方，但不能缺省，具体配置见命令参数；
* 目录必须以`/`结尾，否则Copper会认为是个没有扩展名的文件名；
* 一个条目中最多只能有一个组(不能嵌套，不能并列）。组中只能使用全文件名、文件名，不可使用目录（以`/`结尾的非关键字coper会认为是目录名），即不可存在`/`关键字。组后可选择性的使用通用扩展名，不写通用扩展名coper会认为所有组中没有明确扩展名的文件都是明确不需要扩展名才能匹配成功的；
* 通用扩展名只对组中的内容起作用，组中所有文件名都会使用通用扩展名做为其扩展名；这样规定的原因是文件名中可以有多个小数点，如果组中文件名可以自带扩展名的话，coper无法判断其到底是使用扩展名还是文件名中的一部分；比如条目`aa/<bb.|cc.jpg|dd|ee.ff>.png`，到底是要取`aa/ee.ff`文件还是`aa/ee.ff.png`文件？（前者自带扩展名ff，后者使用了通用扩展名png，而ee.ff只是其文件名而已）；
* 如果有组的话，组前面必须是目录关键字，否则见第3条；
* 组中不能使用通配符；
* 条目只有目录的话，会将该目录下的文件与所有的子目录进行匹配；
* 如果只想处理目录下的所有文件（不遍历子目录），那么需要在目录后面加上`*.*`通配符；
* 正则表达式开始关键字`>>`之后全部是正则表达式的内容，且该关键字之前必须是/关键字，除非是根目录；
* 语法分析器不对正则表达式做检测，这就意味着文件后期操作可能会产生因正则表达式错误而导致的操作失败；


# 通配符的使用 

coper目前只支持星号（*）通配符，它的含义与正则表达式中的一样，表示0个或者多个。？、+通配符暂不支持，不过这根本不影响coper的功能，如果你对正则表达式熟悉的话，什么样格式的文件都能拷贝（coper在目前的设计中不支持目录的正则匹配）。星号（*）通配符也只能支持下面四种写法。

|               语法 | 说明                                                |
| :--: | :--: |
|              *.* | 匹配所有文件                                            |
|                * | 匹配所有没有扩展名的文件                                 |
|               *. | （同上）                                              |
|               .* | 匹配所有没有文件名的文件                                            |

# 命令参数 

coper的命令行内容以parameter关键字开始（必须是最开始的位置），命令之间用非可见字符隔开即可（通常是空格）。有些命令需要参数，比如`parameter -r -t`命令，coper规定所有命令的参数必须用双引号包起来，而且需要与命令留空字符（不限个数），coper并不会非常智能的匹配双引号中的内容，比如 `parameter -r "D:/aaa/bb"cde"/ff/" `这个内容（虽然windows系统不会允许你用双引号做目录名，这里只是举个例子）。coper只会认为 -r的参数是"D:/aaa/bb"，而不是你想要的"D:/aaa/bb"cde"/ff/"，这里需要要注意。coper对命令的解析只会专注于有用的信息，比如`parameter v -y Y -x -r "./root/" -t "./root2/"`这个条目中的v与Y它是不会理会的。只要能识别的命令构成了最小的可运行状态，coper便会执行。

# know bug(s):

* <del>parameter关键字如果是这样：`-v-x -r "D:/xxx/"`，coper不会认为-v是个命令，但觉得-x是个不错的命令。</del> 【fixed】

|  参数  |  说明                                        |  备注            |
| -- | -- | -- | 
|  -r  | 要装载文件的根目录                                  | 必须             |
|  -t  | 目标目录，删除操作可忽略，拷贝与裁剪操作必须。                    |                |
|  -c  | 拷贝                                         | 必须，这3个命令不能共存。  |
|  -d  | 删除                                         |            |
|  -x  | 裁剪                                         |             |
|  -v  | 输出详细的运行消息                                  | 可选，默认false     |
|  -y  | 配置文件有错误的话，会咨询是否继续执行合法条目，如果与-Y命令共存，使用该-y命令  | 可选，默认false     |
|  -Y  | 一路执行合法条目到低，如果与-y命令共存，使用该-y命令               | 可选，默认false     |
|  -f  | 扁平拷贝，只有拷贝命令才生效                             | 待开发            |


