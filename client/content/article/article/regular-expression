
有人说会正则的程序员比较神秘。

正则表达式可能对大部分初学程序的朋友而言是陌生的，因为用不到，用到了也有其他方法变通的解决，其次就是比较少见，实在需要的话也是网上搜搜或者请教前辈。网上有很多优秀的正则表达式讲解，有的非常不错，比如这篇。我主要说说以下几点，目的依然简单：我需要通过一字一字的记录来加强记忆与理解：

#  说明
这里先说下下文可能用到的一些词汇的含义:

* 表达式：一串字符，用来表示某种含义。
* 匹配：指符合给定的正则表达式。
* 匹配内容：指通过正则表达式匹配后得到的被验证的字符串中的某一子串。
* 正则表达式在匹配的时候是逐字符去验证，只要符合就验证下一个字符，不符合重新匹配正则中的第一个字符。

#  转义
所谓转义，就是符号含义并非其字面意思，比如\w表示匹配所有的数字字母下划线，而\d表示匹配所有的数字，下面列出大部分转义表达式

|表达式|说明|
|:--:|:--|
|\d|匹配所有数字|
|\D|匹配所有非数字（上面一项的反面）|
|\w|匹配数字、字母、下划线|
|\W|（上一项的反面）|
|\s|匹配所有的空白字符，比如空格、制表符、回车符等|
|\S|（上一项的反面）|
|\r|匹配回车符|
|\n|匹配换行符|
|\t|匹配水平制表符|
|\v|匹配垂直制表符|
|\u????|匹配以此指定的unicode字符，比如\\u002B就是+号|
|\x??|匹配以此指定的ascii码字符，比如\\x61就是小写字母a|


#  重复
重复就是再一次匹配，比如字符串"abcdef"，如果我想匹配这个字符的话，按照到目前为止的写法，只能写成这样：/\w\w\w\w\w\w/，重复6次，表示匹配验证6次，上面说了正则表达式引擎是逐字符扫描的，当扫描到字符a时，与正则表达式中的第一个进行验证，发现字母a就是\w的一种，然后继续向后检查第二个字符b，发现它也符合正则表达式中的第二个\w，于是继续扫描，直到正则表达式的结束，一路都是符合要求，所有字符串abcdef被选中。这样的话显然比较粗鲁，倘若我需要匹配一长串数字的话，那需要多少个\d了？更主要的原因是我岂能预先知道它会有多少个数字？

|表达式|说明|
|:--:|:--|
|+|前一项正则的内容必须至少出现一次|
|*|前一项正则的内容可有可无|
|?|前一项正则的内容可无，可有的话也只能出现一次|
|{n}|前一项正则的内容必须出现n次|
|{n,}|前一项正则的内容必须至少出现n次|
|{n,m}|前一项正则的内容必须至少出现n次，至多出现m次|

当我们需要匹配与前一项相同的字符时，可以使用表单中的正则符号，比如上面的一长串数字，可以这样写:/\d+/，就是在逐行扫描的过程只只要遇到数字，就算匹配成功，然后后面又是数字的话，依然匹配，直到没有出现数字为止（比如一个空格）；

#  括号

正则表达式中的括号可以有圆括号、方括号、花括号（上面已说明）三个：

##  方括号

方括号在正则中的作用是用来枚举字符，只要有一个命中，整个方括号就算匹配。它的使用形如这样：[xxxx]，[xxx-yyy]，或者这样[^xxxx]，[^xxx-yyy]，其实就两点，第一中间有连字符'-'，表示这个区间；第二有帽子符号'^'，表示不在枚举中的其他字符（反面）；举例来说，我想找到字符串"abc1234def5678g"中的所有数字，这些数字无非就是0到9，可以枚举，所以我们的正则可以这样写：/[0-9]+/，只要数字就匹配。

##  圆括号
圆括号在正则表达式中的作用比较多，至少有三点（参考《JS权威指南》）：

定义子表达式：子表达式就如同嵌入在其中的另一个正则表达式，既然是另一个表达式，那么就可以拥有自己的匹配空间；
定义子匹配模式：可以在所匹配的字符串中抽出匹配括号中子表达式的子字符串；比如字符串"abc1234def"，我希望找到夹杂在字母abc与def之间的数字xxxx，这里的正则表达式就可以写成这样：/abc(\d+)def/，这样当我整个正则匹配到abc1234def的时候，我会从中抽出括号中的东西，而括号中的内容就是我需要的数字。
定义整个正则表达式中后面部分要匹配的模式：后面部分要匹配的字符串可能不太确定，但能确定的是与前面匹配的相同，这样就可以使用括号；这个很好理解，比如你要在一篇文章中查找引号中的内容，你可以像这样写正则：/"[^"]+"/，现在问题来了，有的内容可能在单引号中，于是你可能再写一个相同样子的正则比如/'[^']+'/从而再执行一边查找，这当然没有问题。但如果我们要求你只能写一个呢？这就用到了圆括号。正则就像这样：/(['"])[^'"]+\1/，其中\1就是再次匹配与前面第一个圆括号中内容相同的字符，如果前面找到了单引号，后面就匹配单引号，类同。

#  引用

引用就是利用圆括号的第二、三个作用，就是获取完整正则表达式中的子表达式。这样做的目的要么是获取子表达式，在其他非正则的地方使用，要么是正则本身在后期使用子字符串。举例来说： 我有一份10000多页的电子文档，里面有字母、数字、还有其他什么怪异的符号。单就数字而言，有的表示金额，有的表示电话号码等等。倘若有人告诉我一个这篇文档中的数字，我肯定不能确定这这个数字是金额数字还是电话号码。但我能确定的是所有的电话号码前面总有："TEL:"。我如何输出文档中全部的电话号码？

这个问题就需要利用正则中的引用，我们先写能匹配所有这种模式的正则表达式：/TEL:\d+/，然后需要从其中引用到一个子表达式，该子表达式表示电话号码，正则标称这样：/TEL:(\d+)/，这样经过匹配后，所有的电话号码就能得到了，这是使用引用内容的例子。正则后期使用的例子就比如上面的单双引号。

#  分组

我们用|来进行选择性的匹配，意思就是说：要么你能匹配上，要么我能匹配上，要么大家都能匹配上，无论谁匹配上了都表示命中。比如我希望统计一片文章中的出现的hello world数量，这个hello world可以有好多写法：Hello World、Hello world、hello world、hello World，其中hello与world之间没准是个空格，没准是个制表符，没准是个其他非可视的字符，也没准重复多少次。我就可以这样写正则：/(h|H)ello\s+(w|W)orld/，其中|就是分支，在圆括号中的字母（此时圆括号起到了第一种作用）h与H都行。**这里需要注意的是：分支优先匹配左边的，只要成功，右边不予考虑。**比如：/(sgg|sggg)/，他可以匹配sgg也可以匹配sggg，当出现sgggggggg的时候，只有其中前3个字符（sggg）被匹配，因为分组中左边的有优先权。

#  定位

定位算是正则中的高级话题，定位的作用就是在正则查找的时候需要，输出匹配内容的时候不需要，所以才叫定位嘛。最常见的定位就是开头定位与结尾定位，还有其他的比如零宽正向先行断言、零宽正向后行断言等，见下表。

|编号|名称/符号|举例|说明|
|:--:|:--:|:--:|:--|
|1|^|^[1-9]\d/|匹配以非零数字开头的数字|
|2|$|/\d[1-9]$/|必须以非零数字结尾的数字，但开头可以有零|
|3|零宽正向先行断言|/\d(?=￥)/|数字后面必须要有￥符号，否则不匹配，但匹配内容只有数字|
|4|零宽反向先行断言|/\d(?!=￥)/|数字后面必须不能有￥符号，否则不匹配，但匹配内容只有数字|
|5|零宽正向后行断言|/(?<=￥)\d/|数字前面必须要有￥符号，否则不匹配，但匹配内容只有数字|

第5种匹配方式浏览器中的正则引擎不能识别，其他语言没有尝试过，不过微软的MSDN中也没有对后行断言的说明，感觉是要被废掉的样子。

#  JS测试

http://www.regexlab.com/zh/regref.htm<br>
https://msdn.microsoft.com/zh-cn/library/ae5bf541(VS.80).aspx<br>
http://tool.oschina.net/regex/
